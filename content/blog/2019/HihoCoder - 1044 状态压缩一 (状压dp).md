---
title: HihoCoder - 1044 状态压缩一 (状压dp)
date: 2019-01-29T16:07:37+08:00
lastmod: 2019-01-29T16:07:37+08:00
draft: false
featured_image: https://i.loli.net/2019/01/29/5c5009a934f2d.png
tags:
- 状压dp
categories: OnlineJudge刷题
comment: true

---

## 描述

> 小Hi和小Ho在兑换到了喜欢的奖品之后，便继续起了他们的美国之行，思来想去，他们决定乘坐火车前往下一座城市——那座城市即将举行美食节！
>
> 但是不幸的是，小Hi和小Ho并没有能够买到很好的火车票——他们只能够乘坐最为破旧的火车进行他们的旅程。
>
> 不仅如此，因为美食节的吸引，许多人纷纷踏上了和小Hi小Ho一样的旅程，于是有相当多的人遭遇到了和小Hi小Ho一样的情况——这导致这辆车上的人非常非常的多，以至于都没有足够的位置能让每一个人都有地方坐下来。
>
> 小Hi和小Ho本着礼让他们的心情——当然还因为本来他们买的就是站票，老老实实的呆在两节车厢的结合处。他们本以为就能够这样安稳抵达目的地，但事与愿违，他们这节车厢的乘务员是一个强迫症，每隔一小会总是要清扫一次卫生，而时值深夜，大家都早已入睡，这种行为总是会惊醒一些人。而一旦相邻的一些乘客被惊醒了大多数的话，就会同乘务员吵起来，弄得大家都睡不好。
>
> 将这一切看在眼里的小Hi与小Ho决定利用他们的算法知识，来帮助这个有着强迫症的乘务员——在不与乘客吵起来的前提下尽可能多的清扫垃圾。
>
> 小Hi和小Ho所处的车厢可以被抽象成连成一列的N个位置，按顺序分别编号为1..N，每个位置上都有且仅有一名乘客在休息。同时每个位置上都有一些垃圾需要被清理，其中第i个位置的垃圾数量为Wi。乘务员可以选择其中一些位置进行清理，但是值得注意的是，一旦有编号连续的M个位置中有超过Q个的位置都在这一次清理中被选中的话（即这M个位置上的乘客有至少Q+1个被惊醒了），就会发生令人不愉快的口角。而小Hi和小Ho的任务是，计算选择哪些位置进行清理，在不发生口角的情况下，清扫尽可能多的垃圾。
>
> [提示一：无论是什么动态规划，都需要一个状态转移方程！](http://hihocoder.com/problemset/problem/1044#)
>
> [提示二：好像什么不对劲？状态压缩哪里去了？](http://hihocoder.com/problemset/problem/1044#)

## 输入

> 每个测试点（输入文件）有且仅有一组测试数据。
>
> 每组测试数据的第一行为三个正整数N、M和Q，意义如前文所述。
>
> 每组测试数据的第二行为N个整数，分别为W1到WN，代表每一个位置上的垃圾数目。
>
> 对于100%的数据，满足N<=1000, 2<=M<=10,1<=Q<=M, Wi<=100
>

## 输出

> 对于每组测试数据，输出一个整数Ans，表示在不发生口角的情况下，乘务员最多可以清扫的垃圾数目。
>

## 样例输入

```
5 2 1
36 9 80 69 85 
```

## 样例输出

```
201
```

## 思路

题意是给出有 $n$ 个数的数组，每一个位置有一个权值 $w[i]$ ，现在你需要选择一些位置，使得取得的权值和最大。

选择位置的条件是：对于任意长度为 $m$ 的区间，选择的位置的数量必须**小于等于** $q$ 个。

思路是状态压缩。因为 $m$ 的范围是 $10$ ,那么用二进制的思想，二进制为 $1$ 表示当前位置被选择，为 $0$ 表示没有被选择，那么一共需要 $m$ 个二进制位来表示状态，那么压缩成十进制，就需要 $2^m-1$ 个状态来表示。

定义：

- $dp[i][j]$ 表示前 $i$ 个位置，选择的状态为 $j$ 时所能达到的最大价值。
- $j$ 表示的状态是，以第 $i$ 个位置为结尾的连续 $m$ 个位置的选取状态。

举个例子，假设当 $m=3$ 时，所有的状态为：

```
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1
```

那么，`dp[4][1 0 1]​` 的值由谁转移而来？

`1 0 1` 中最后一个 1 代表 4 这个位置已经被选择，那么 2 3 这两个位置的选择情况是 `1 0` ，那么 2 3 这两个位置的状态不能改变，唯一能改变的就是 1 这个位置的状态，那么我们就有 `dp[3][0 1 0]` 和 `dp[3][1 1 0]`这两个状态可以转移到 `dp[4][1 0 1]`。

那么这个题目的状态转移方程就是：

- 当前状态的最后一位为 1 时（选择这个位置）：

  $dp[i][j] = max(dp[i - 1][j >> 1], dp[i - 1][(j >> 1) | (1 << (m - 1))]) + w[i]​$

- 当前状态的最后一位为 0 时（不选这个位置）：

  $dp[i][j] = max(dp[i - 1][j >> 1], dp[i - 1][(j >> 1) | (1 << (m - 1))])$

在枚举状态的时候，注意如果当前状态二进制中 1 的个数超过给顶的数 $q$ 就跳过

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define mem(a, b) memset(a, b, sizeof(a))
const int N = 1e3 + 10;
int dp[N][(1 << 10) + 5];
int w[N];
int get_cnt(int n)
{
    int cnt = 0;
    while (n)
    {
        cnt++;
        n = n & (n - 1);
    }
    return cnt;
}
int main()
{
    //freopen("in.txt", "r", stdin);
    int n, m, q;
    scanf("%d%d%d", &n, &m, &q);
    for (int i = 1; i <= n; i++)
        scanf("%d", &w[i]);
    for (int i = 1; i <= n; i++)
    {
        for (int j = 0; j < (1 << m); j++)
        {
            if (get_cnt(j) > q)
                continue;
            if (j & 1)
                dp[i][j] = max(dp[i - 1][j >> 1], dp[i - 1][(j >> 1) | (1 << (m - 1))]) + w[i];
            else
                dp[i][j] = max(dp[i - 1][j >> 1], dp[i - 1][(j >> 1) | (1 << (m - 1))]);
        }
    }
    int ans = 0;
    for (int i = 0; i < (1 << m); i++)
        ans = max(ans, dp[n][i]);
    printf("%d\n", ans);
    return 0;
}
```

